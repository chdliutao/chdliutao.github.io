<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chdliutao.top","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="好好写代码，开发优质产品。">
<meta name="keywords" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="CHD-刘涛">
<meta property="og:url" content="http:&#x2F;&#x2F;chdliutao.top&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="CHD-刘涛">
<meta property="og:description" content="好好写代码，开发优质产品。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chdliutao.top/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>CHD-刘涛</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CHD-刘涛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/06/06/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/06/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">Go知识复习-指针</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-06T00:00:00+08:00">2019-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 15:38:45" itemprop="dateModified" datetime="2020-07-02T15:38:45+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go知识复习—指针"><a href="#Go知识复习—指针" class="headerlink" title="Go知识复习—指针"></a>Go知识复习—指针</h1><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，只有两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p>
<h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<code>Go</code>语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 <code>Go</code>语言中的值类型（<code>int</code>、<code>float</code>、<code>bool</code>、<code>string</code>、<code>array</code>、<code>struct</code>）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p>
<p>取变量指针的语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>v</code>:代表被取地址的变量，类型为<code>T</code></li>
<li><code>ptr</code>:用于接收地址的变量，<code>ptr</code>的类型就为<code>*T</code>，称做<code>T</code>的指针类型。*代表指针。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := &amp;a</span><br><span class="line">	fmt.Printf(<span class="string">"a:%d ptr:%p\n"</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">	fmt.Printf(<span class="string">"b:%p type:%T\n"</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">	fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="./Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E6%8C%87%E9%92%88.assets/image-20200426200624501.png" alt="image-20200426200624501"></p>
<h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h3><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//指针取值</span></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := &amp;a <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">	fmt.Printf(<span class="string">"type of b:%T\n"</span>, b)</span><br><span class="line">	c := *b <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">	fmt.Printf(<span class="string">"type of c:%T\n"</span>, c)</span><br><span class="line">	fmt.Printf(<span class="string">"value of c:%v\n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of b:*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> of c:<span class="keyword">int</span></span><br><span class="line">value of c:<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>
<p><strong>指针传值示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	modify1(a)</span><br><span class="line">	fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">	modify2(&amp;a)</span><br><span class="line">	fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>先来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">	*a = <span class="number">100</span></span><br><span class="line">	fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码会引发<code>panic</code>，为什么呢？ 在<code>Go</code>语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的<code>new</code>和<code>make</code>。 <code>Go</code>语言中<code>new</code>和<code>make</code>是内建的两个函数，主要用来分配内存。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>Type</code>表示类型，<code>new</code>函数只接受一个参数，这个参数是一个类型</li>
<li><code>*Type</code>表示类型指针，<code>new</code>函数返回一个指向该类型内存地址的指针。</li>
</ul>
<p><code>new</code>函数不太常用，使用<code>new</code>函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">	b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">	fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">	fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量<code>a</code>但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的<code>new</code>函数对<code>a</code>进行初始化之后就可以正常对其赋值了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">	a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">	*a = <span class="number">10</span></span><br><span class="line">	fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p><code>make</code>也是用于内存分配的，区别于<code>new</code>，它只用于<code>slice</code>、<code>map</code>以及<code>chan</code>的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。<code>make</code>函数的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p><code>make</code>函数是无可替代的，我们在使用<code>slice</code>、<code>map</code>以及<code>channel</code>的时候，都需要使用<code>make</code>进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于<code>channel</code>我们会在后续的章节详细说明。</p>
<p>本节开始的示例中<code>var b map[string]int</code>只是声明变量<code>b</code>是一个<code>map</code>类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h3><ol>
<li>二者都是用来做内存分配的。</li>
<li><code>make</code>只用于<code>slice</code>、<code>map</code>以及<code>channel</code>的初始化，返回的还是这三个引用类型本身；</li>
<li>而<code>new</code>用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/06/05/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/05/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Go知识复习-反射</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-05T00:00:00+08:00">2019-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 15:35:31" itemprop="dateModified" datetime="2020-07-02T15:35:31+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go知识复习—反射"><a href="#Go知识复习—反射" class="headerlink" title="Go知识复习—反射"></a>Go知识复习—反射</h1><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：同一时间段内执行多个任务</p>
<p>并行：同一时刻执行多个任务</p>
<p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p>
<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p>
<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>
<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>
<h4 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h4><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<h4 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h4><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p>
<p>举个例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello()</span><br><span class="line">	fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p>
<p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p>
<p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p>
<p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>
<p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p>
<p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
<h4 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h4><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p>
<h3 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h3><h4 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>
<h4 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h4><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个<code>groutine</code>最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html" target="_blank" rel="noopener">[深入Golang调度器之GMP模型]</a></p>
<h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ol>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ol>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h4 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h4><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure>

<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>

<h4 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h4><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>

<p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p>
<p>创建channel的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure>

<p>channel的缓冲大小是可选的。</p>
<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<h4 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h4><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<h5 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h5><p>将一个值发送到通道中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure>

<h5 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h5><p>从一个通道中接收值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure>

<h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<h4 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h4><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br></pre></td></tr></table></figure>

<p>为什么会出现<code>deadlock</code>错误呢？</p>
<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ret := &lt;-c</span><br><span class="line">	fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h4 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h4><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>
<h4 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h4><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p>
<p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p>
<p>我们来看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			ch1 &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch1)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ch2 &lt;- i * i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch2)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p>
<h4 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h4><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		out &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">		out &lt;- i * i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> counter(ch1)</span><br><span class="line">	<span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">	printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入<code>int</code>类型值），可以对其执行发送操作但是不能执行接收操作；</li>
<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取<code>int</code>类型值），可以对其执行接收操作但是不能执行发送操作。</li>
</ul>
<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>
<h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p>
<p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p>
<h3 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h3><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>
<p>一个简易的<code>work pool</code>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"worker:%d start job:%d\n"</span>, id, j)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">"worker:%d end job:%d\n"</span>, id, j)</span><br><span class="line">		results &lt;- j * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="comment">// 开启3个goroutine</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5个任务</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">	<span class="comment">// 输出结果</span></span><br><span class="line">	<span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">5</span>; a++ &#123;</span><br><span class="line">		&lt;-results</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h3><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>
<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个小例子来演示下<code>select</code>的使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">			fmt.Println(x)</span><br><span class="line">		<span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>
</ul>
<h3 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h3><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		x = x + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">		x = x + <span class="number">1</span></span><br><span class="line">		lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>
<h4 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h4><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<p>读写锁示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x      <span class="keyword">int64</span></span><br><span class="line">	wg     sync.WaitGroup</span><br><span class="line">	lock   sync.Mutex</span><br><span class="line">	rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">	rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">	x = x + <span class="number">1</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">	rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">	<span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">	rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">	time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">	rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">	<span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> write()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> read()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h4 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a><code>sync.WaitGroup</code></h4><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。<code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>(wg * WaitGroup) Add(delta int)</code></td>
<td align="center">计数器+delta</td>
</tr>
<tr>
<td align="center"><code>(wg *WaitGroup) Done()</code></td>
<td align="center">计数器-1</td>
</tr>
<tr>
<td align="center"><code>(wg *WaitGroup) Wait()</code></td>
<td align="center">阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
<h4 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a><code>sync.Once</code></h4><p>说在前面的话：这是一个进阶知识点。</p>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p>
<h5 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h5><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在<code>init</code>函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">	icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">		<span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line">		<span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line">		<span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line">		<span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">		loadIcons()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">	icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">	icons[<span class="string">"left"</span>] = loadIcon(<span class="string">"left.png"</span>)</span><br><span class="line">	icons[<span class="string">"up"</span>] = loadIcon(<span class="string">"up.png"</span>)</span><br><span class="line">	icons[<span class="string">"right"</span>] = loadIcon(<span class="string">"right.png"</span>)</span><br><span class="line">	icons[<span class="string">"down"</span>] = loadIcon(<span class="string">"down.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">	icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">		<span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line">		<span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line">		<span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line">		<span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">	loadIconsOnce.Do(loadIcons)</span><br><span class="line">	<span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h5><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h4 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a><code>sync.Map</code></h4><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			set(key, n)</span><br><span class="line">			fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, get(key))</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n)</span><br><span class="line">			value, _ := m.Load(key)</span><br><span class="line">			fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h4 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/06/02/%E4%BD%BF%E7%94%A8PHP%E5%8A%A0Python%E8%BF%9B%E8%A1%8C%E4%B8%87%E8%83%BD%E8%A1%A8%E5%8D%95%E7%BB%93%E6%9E%9C%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/%E4%BD%BF%E7%94%A8PHP%E5%8A%A0Python%E8%BF%9B%E8%A1%8C%E4%B8%87%E8%83%BD%E8%A1%A8%E5%8D%95%E7%BB%93%E6%9E%9C%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">使用PHP加Python进行万能表单结果统计.md</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 20:56:02" itemprop="dateCreated datePublished" datetime="2019-06-02T20:56:02+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 14:10:28" itemprop="dateModified" datetime="2020-03-09T14:10:28+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">项目总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="通过PHP与Python对表单提交结果进行统计"><a href="#通过PHP与Python对表单提交结果进行统计" class="headerlink" title="通过PHP与Python对表单提交结果进行统计"></a>通过PHP与Python对表单提交结果进行统计</h1><h3 id="小程序万能表单设计"><a href="#小程序万能表单设计" class="headerlink" title="小程序万能表单设计"></a>小程序万能表单设计</h3><h4 id="数据表结构："><a href="#数据表结构：" class="headerlink" title="数据表结构："></a>数据表结构：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表单总表:form</span><br><span class="line">`ID`</span><br><span class="line">`title`			表单名称</span><br><span class="line">`desc`			表单描述</span><br><span class="line">`create_time`	创建时间</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">表单配置表:form_config</span><br><span class="line">`ID`</span><br><span class="line">`form_id`		表单ID</span><br><span class="line">`start_time`	开始日期</span><br><span class="line">`end_time`		截止日期</span><br><span class="line">`YXDM`			院系代码(为0则不考虑)</span><br><span class="line">`NJDM`			年级代码(为0则不考虑)</span><br><span class="line">`BJDM`			班级代码(为0则不考虑)</span><br><span class="line">`status`		问卷状态（0关闭,1开启）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表单问卷表:form_questionnaire</span><br><span class="line">`ID`</span><br><span class="line">`form_id`		表单ID</span><br><span class="line">`title`			表单标题</span><br><span class="line">`type`			表单类型（text，textarea，select，radio，image，position）</span><br><span class="line">`extra`			补充说明（selector,multiSelector,time,date,region参考[微信文档](https://developers.weixin.qq.com/miniprogram/dev/component/picker.html)）</span><br><span class="line">`placeholder`	前端输入框提示</span><br><span class="line">`options`		选项</span><br><span class="line">`status`		是否可见</span><br><span class="line">`must`			是否必须</span><br><span class="line">`validate`		验证规则(phone,number(1-100),require)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">结果记录表form_result</span><br><span class="line">`ID`		</span><br><span class="line">`config_id`		配置ID</span><br><span class="line">`form_id`		表单ID</span><br><span class="line">`user_id`		学号或者工号</span><br><span class="line">`open_id`		用户openid</span><br><span class="line">`title`			问题标题</span><br><span class="line">`value`			用户答案</span><br><span class="line">`timestamp`		填写时间</span><br></pre></td></tr></table></figure>

<p>用户填写了两个问卷，现在需要对问卷结果进行统计。统计每个选项选择人数所占百分比。<br>问卷1要求对总体进行统计，对每个年级进行统计，对男女分别统计，对是否班干部进行统计。<br>问卷2要求对总体进行统计，对年级以及男女进行统计。</p>
<p>初步思路：由于PHP操作数据较方便，因此由PHP获取统计数据后，用Python jupyter 写入Excel。</p>
<p>PHP统计思路：首先获取总填写人数，之后获取到表单的options，对于每个options都去数据库中统计该选项的人数，之后算出比率，以json格式返回，之后用Python请求接口，将数据写入Excel。之后需要更换统计条件时，便修改查询条件直至Excel统计表完成。</p>
<p>结果：获取一次数据的时间为40s，之后需要重复修改查询条件，如form_id以及年级等等。</p>
<p>PHP 代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">set_time_limit(<span class="number">0</span>);</span><br><span class="line">$form_id = <span class="number">2</span>;</span><br><span class="line">$nj = <span class="string">"2016"</span>;</span><br><span class="line">$finishedStuCount = Db::view(<span class="string">"form_result"</span>)</span><br><span class="line">	<span class="comment">// -&gt; where("value","学生干部")</span></span><br><span class="line">	-&gt; group(<span class="string">"user_id"</span>)</span><br><span class="line">	-&gt; where(<span class="string">"form_id"</span>,$form_id)</span><br><span class="line">	-&gt; view(<span class="string">"stu_detail"</span>,<span class="string">"YXDM,XH"</span>,<span class="string">"form_result.user_id = stu_detail.XH"</span>)</span><br><span class="line">	<span class="comment">// -&gt; where("user_id","LIKE","$nj%")</span></span><br><span class="line">	<span class="comment">// -&gt; where("XBDM",2)</span></span><br><span class="line">   -&gt; count();</span><br><span class="line">$questionnaire=Db::name(<span class="string">"form_questionnaire"</span>)-&gt;where(<span class="string">"form_id"</span>,$form_id) -&gt; select();</span><br><span class="line">$result = [</span><br><span class="line">    <span class="string">"ques1"</span> =&gt;  [],</span><br><span class="line">    <span class="string">"ques2"</span> =&gt;  [],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">foreach</span> ($questionnaire <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">if</span> ($value[<span class="string">"type"</span>] == <span class="string">"radio"</span>) &#123;</span><br><span class="line">        $temp = [</span><br><span class="line">        	<span class="string">"title"</span> =&gt;  $value[<span class="string">"title"</span>],</span><br><span class="line">        ];</span><br><span class="line">        $options = json_decode($value[<span class="string">"options"</span>],<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">foreach</span> ($options <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">			$stuCount = Db::name(<span class="string">"form_result"</span>)</span><br><span class="line">				<span class="comment">// -&gt; where("user_id","IN",function($query)&#123;</span></span><br><span class="line">				<span class="comment">// $query-&gt;table('fa_form_result')-&gt;where('value',"学生干部")-&gt;group("user_id")-&gt;field('user_id');</span></span><br><span class="line">				<span class="comment">// &#125;)</span></span><br><span class="line">				-&gt; group(<span class="string">"user_id"</span>)</span><br><span class="line">				<span class="comment">// -&gt; view("stu_detail","YXDM,XH","form_result.user_id = stu_detail.XH")</span></span><br><span class="line">                <span class="comment">// -&gt; where("user_id","LIKE","$nj%")</span></span><br><span class="line">                <span class="comment">// -&gt; where("XBDM",2)</span></span><br><span class="line">                <span class="comment">// -&gt; where("user_id","LIKE","$nj%")</span></span><br><span class="line">                -&gt; where(<span class="string">"form_id"</span>,$form_id)</span><br><span class="line">                -&gt; where(<span class="string">"title"</span>,$value[<span class="string">"title"</span>])</span><br><span class="line">                -&gt; where(<span class="string">"value"</span>,$v)</span><br><span class="line">                -&gt; count(); </span><br><span class="line">		$rate = round($stuCount/$finishedStuCount,<span class="number">4</span>);</span><br><span class="line">		$temp[<span class="string">"data"</span>][]   = $rate;</span><br><span class="line">       	&#125;</span><br><span class="line">    $result[<span class="string">"ques1"</span>][] = $temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($value[<span class="string">"type"</span>] == <span class="string">"checkbox"</span>) &#123;</span><br><span class="line">        $temp = [</span><br><span class="line">            <span class="string">"title"</span> =&gt;  $value[<span class="string">"title"</span>],</span><br><span class="line">        ];</span><br><span class="line">        $options = json_decode($value[<span class="string">"options"</span>],<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">foreach</span> ($options <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $stuCount = Db::name(<span class="string">"form_result"</span>)</span><br><span class="line">            <span class="comment">// -&gt; where("user_id","IN",function($query)&#123;</span></span><br><span class="line">            <span class="comment">//    $query-&gt;table('fa_form_result')-&gt;where('value',"学生干部")-&gt;group("user_id")-&gt;field('user_id');</span></span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">            -&gt; group(<span class="string">"user_id"</span>)</span><br><span class="line">            -&gt; where(<span class="string">"form_id"</span>,$form_id)</span><br><span class="line">            <span class="comment">// -&gt; where("user_id","LIKE","$nj%")</span></span><br><span class="line">            <span class="comment">// -&gt; view("stu_detail","YXDM,XH","form_result.user_id = stu_detail.XH")</span></span><br><span class="line">            <span class="comment">// -&gt; where("user_id","LIKE","$nj%")</span></span><br><span class="line">            <span class="comment">// -&gt; where("XBDM",2)</span></span><br><span class="line">            -&gt; where(<span class="string">"title"</span>,$value[<span class="string">"title"</span>])</span><br><span class="line">            -&gt; where(<span class="string">"value"</span>,<span class="string">"LIKE"</span>,<span class="string">"%$v%"</span>)</span><br><span class="line">            -&gt; count(); </span><br><span class="line">            $rate = round($stuCount/$finishedStuCount,<span class="number">4</span>);</span><br><span class="line">            $temp[<span class="string">"data"</span>][]   = $rate;</span><br><span class="line">        &#125;</span><br><span class="line">        $result[<span class="string">"ques1"</span>][] = $temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> json($result);</span><br></pre></td></tr></table></figure>

<p>Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line">url = <span class="string">"http://localhost:8080/yibanbx/public/api/index/index"</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">elapsed = (time.clock() - start)</span><br><span class="line"></span><br><span class="line">res = json.loads(response.text)</span><br><span class="line">ques = res[<span class="string">"ques1"</span>]</span><br><span class="line">result = &#123;&#125;</span><br><span class="line">columns = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ques:</span><br><span class="line">    columns.append(i[<span class="string">"title"</span>])</span><br><span class="line">    <span class="keyword">while</span> len(i[<span class="string">"data"</span>]) &lt; <span class="number">9</span> :</span><br><span class="line">        i[<span class="string">"data"</span>].append(<span class="string">""</span>)</span><br><span class="line">    result[i[<span class="string">"title"</span>]] = i[<span class="string">"data"</span>]</span><br><span class="line">dataFrame = pd.DataFrame(result)</span><br><span class="line">dataFrame.to_csv(<span class="string">"test.csv"</span>,index=<span class="literal">False</span>,sep=<span class="string">','</span>,encoding = <span class="string">'utf_8_sig'</span>,columns = columns)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># res = json.loads(response.text)</span></span><br><span class="line"><span class="comment"># columns = res.keys()</span></span><br><span class="line"><span class="comment"># dataFrame = pd.DataFrame(res)</span></span><br><span class="line"><span class="comment"># dataFrame.to_csv("test.csv",index=False,sep=',',encoding = 'utf_8_sig',columns = columns)</span></span><br></pre></td></tr></table></figure>

<p>时间优化：</p>
<p>1.思考避免在循环中进行SQL查询。因此先一次性将数据查出，对数组进行处理。</p>
<p>2.在Python请求时可以添加参数，这样可以同时进行多个请求。</p>
<p>本次代码需要注意的地方：</p>
<p>Python部分：由于字典类似于哈希表，存储时乱序因此写入csv时需要加入columns参数固定列的顺序。同时to_csv函数要保证写的数据行数相同，因此需要对数据进行清洗。</p>
<p>PHP部分：thinkPHP框架的子查询书写方式：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$stuCount = Db::name(<span class="string">"form_result"</span>)</span><br><span class="line">    <span class="comment">// -&gt; where("user_id","IN",function($query)&#123;</span></span><br><span class="line">    <span class="comment">//    $query-&gt;table('fa_form_result')-&gt;where('value',"学生干部")-&gt;group("user_id")-&gt;field('user_id');</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/05/13/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/13/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/" class="post-title-link" itemprop="url">Go知识复习-结构体</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-13T00:00:00+08:00">2019-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 15:43:25" itemprop="dateModified" datetime="2020-07-02T15:43:25+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go知识复习—结构体"><a href="#Go知识复习—结构体" class="headerlink" title="Go知识复习—结构体"></a>Go知识复习—结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面</p>
<p>向对象具有更高的扩展性和灵活性。</p>
<h3 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h3><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>int</code>、<code>float</code>、<code>bool</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p>
<p>类型别名规定：<code>TypeAlias</code>只是<code>Type</code>的别名，本质上<code>TypeAlias</code>与<code>Type</code>是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure>

<p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>

<h4 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h4><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a NewInt</span><br><span class="line">	<span class="keyword">var</span> b MyInt</span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">	fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现面向对象。</p>
<h4 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h4><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ul>
<p>举个例子，定义一个<code>Person</code>（人）结构体，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样类型的字段也可以写在一行，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, city <span class="keyword">string</span></span><br><span class="line">	age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>
<h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure>

<h4 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h4><p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p1 person</span><br><span class="line">	p1.name = <span class="string">"留出安置"</span></span><br><span class="line">	p1.city = <span class="string">"河南"</span></span><br><span class="line">	p1.age = <span class="number">18</span></span><br><span class="line">	fmt.Printf(<span class="string">"p1=%v\n"</span>, p1)  <span class="comment">//p1=&#123;留出安置 河南 18&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">"p1=%#v\n"</span>, p1) <span class="comment">//p1=main.person&#123;name:"留出安置", city:"河南", age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p>
<h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">"王子"</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h4><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p>
<p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	me := <span class="built_in">new</span>(person)</span><br><span class="line">	my := *me</span><br><span class="line">	my2 := me</span><br><span class="line">	me.age = <span class="number">18</span></span><br><span class="line">	me.city = <span class="string">"河南"</span></span><br><span class="line">	me.name = <span class="string">"刘涛"</span></span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, me)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, my)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, my2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;main.person&#123;name:&quot;刘涛&quot;, city:&quot;河南&quot;, age:18&#125;</span><br><span class="line">main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">&amp;main.person&#123;name:&quot;刘涛&quot;, city:&quot;河南&quot;, age:18&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h4><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">"七米"</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">"成都"</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"七米", city:"成都", age:30&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p>
<h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h3><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p4 person</span><br><span class="line">	fmt.Printf(<span class="string">"p4=%#v\n"</span>, p4) <span class="comment">//p4=main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h4><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">	name: <span class="string">"小王子"</span>,</span><br><span class="line">	city: <span class="string">"北京"</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p5=%#v\n"</span>, p5) <span class="comment">//p5=main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以对结构体指针进行键值对初始化，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">	name: <span class="string">"小王子"</span>,</span><br><span class="line">	city: <span class="string">"北京"</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p6=%#v\n"</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure>

<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">	city: <span class="string">"北京"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p7=%#v\n"</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:"", city:"北京", age:0&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h4><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">	<span class="string">"沙河娜扎"</span>,</span><br><span class="line">	<span class="string">"北京"</span>,</span><br><span class="line">	<span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p8=%#v\n"</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:"沙河娜扎", city:"北京", age:28&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用这种格式初始化时，需要注意：</p>
<ol>
<li>必须初始化结构体的所有字段。</li>
<li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>该方式不能和键值初始化方式混用。</li>
</ol>
<h3 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h3><p>结构体占用一块连续的内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int8</span></span><br><span class="line">	b <span class="keyword">int8</span></span><br><span class="line">	c <span class="keyword">int8</span></span><br><span class="line">	d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"n.a %p\n"</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">"n.b %p\n"</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">"n.c %p\n"</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">"n.d %p\n"</span>, &amp;n.d)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure>

<p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com" target="_blank" rel="noopener">在 Go 中恰到好处的内存对齐</a></p>
<h3 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h3><p>空结构体是不占用空间的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;name: <span class="string">"小王子"</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">"娜扎"</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">"大王八"</span>, age: <span class="number">9000</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		m[stu.name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, <span class="string">"=&gt;"</span>, v.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大王八	=&gt;	大王八</span><br><span class="line">小王子	=&gt;	大王八</span><br><span class="line">娜扎	 =&gt;	 大王八</span><br></pre></td></tr></table></figure>

<p>原因分析：</p>
<p>GO语言中的<code>for range</code>遍历时，是使用副本的方式，即每次遍历都将值赋给一个新的地址空间，所以</p>
<p><code>m[stu.Name]=&amp;stu</code>实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。</p>
<p><code>for range</code>创建了每个元素的副本，而不是直接返回每个元素的引用，如果使用该值变量的地址作为指向每个元</p>
<p>素的指针，就会导致错误，在迭代时，<strong>返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以值的地</strong></p>
<p><strong>址总是相同的。</strong></p>
<p> 就像要修改切片元素的属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">    stu.Age = stu.Age+<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是不可行的，要想取得切片的值，则需要用下标进行选取。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *student)</span> <span class="title">newStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	stu.name = name</span><br><span class="line">	stu.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	me := <span class="built_in">new</span>(student)</span><br><span class="line">	me.newStudent(<span class="string">"王子"</span>, <span class="number">22</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v"</span>, me)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;main.student&#123;name:<span class="string">"王子"</span>, age:<span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h3><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>方法的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">newStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s.name = name</span><br><span class="line">	s.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is dream"</span>, s.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	me := <span class="built_in">new</span>(student)</span><br><span class="line">	me.newStudent(<span class="string">"王子"</span>, <span class="number">22</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, me)</span><br><span class="line">	me.dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方</p>
<p>法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为</p>
<p><code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获</p>
<p>取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h3 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于</p>
<p>内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello, 我是一个int。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m1 MyInt</span><br><span class="line">	m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">	m1 = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">"%#v  %T\n"</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>
<h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;</span><br><span class="line">		<span class="string">"小王子"</span>,</span><br><span class="line">		<span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, p1)        <span class="comment">//main.Person&#123;string:"北京", int:18&#125;</span></span><br><span class="line">	fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能</p>
<p>有一个。</p>
<h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user1 := User&#123;</span><br><span class="line">		Name:   <span class="string">"小王子"</span>,</span><br><span class="line">		Gender: <span class="string">"男"</span>,</span><br><span class="line">		Address: Address&#123;</span><br><span class="line">			Province: <span class="string">"山东"</span>,</span><br><span class="line">			City:     <span class="string">"威海"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)<span class="comment">//user1=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user2 User</span><br><span class="line">	user2.Name = <span class="string">"小王子"</span></span><br><span class="line">	user2.Gender = <span class="string">"男"</span></span><br><span class="line">	user2.Address.Province = <span class="string">"山东"</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">	user2.City = <span class="string">"威海"</span>                <span class="comment">//直接访问匿名结构体的字段名</span></span><br><span class="line">	fmt.Printf(<span class="string">"user2=%#v\n"</span>, user2) <span class="comment">//user2=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p>
<h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province   <span class="keyword">string</span></span><br><span class="line">	City       <span class="keyword">string</span></span><br><span class="line">	CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">	Account    <span class="keyword">string</span></span><br><span class="line">	CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Address</span><br><span class="line">	Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user3 User</span><br><span class="line">	user3.Name = <span class="string">"沙河娜扎"</span></span><br><span class="line">	user3.Gender = <span class="string">"男"</span></span><br><span class="line">	<span class="comment">// user3.CreateTime = "2019" //ambiguous selector user3.CreateTime</span></span><br><span class="line">	user3.Address.CreateTime = <span class="string">"2000"</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">	user3.Email.CreateTime = <span class="string">"2000"</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s会动！\n"</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Feet    <span class="keyword">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s会汪汪汪~\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := &amp;Dog&#123;</span><br><span class="line">		Feet: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">"乐乐"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">	d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h3 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生</p>
<p>成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分</p>
<p>隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title    <span class="keyword">string</span></span><br><span class="line">	Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := &amp;Class&#123;</span><br><span class="line">		Title:    <span class="string">"101"</span>,</span><br><span class="line">		Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		stu := &amp;Student&#123;</span><br><span class="line">			Name:   fmt.Sprintf(<span class="string">"stu%02d"</span>, i),</span><br><span class="line">			Gender: <span class="string">"男"</span>,</span><br><span class="line">			ID:     i,</span><br><span class="line">		&#125;</span><br><span class="line">		c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">	data, err := json.Marshal(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"json:%s\n"</span>, data)</span><br><span class="line">	<span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">	str := <span class="string">`&#123;"Title":"101","Students":[&#123;"ID":0,"Gender":"男","Name":"stu00"&#125;,&#123;"ID":1,"Gender":"男","Name":"stu01"&#125;,&#123;"ID":2,"Gender":"男","Name":"stu02"&#125;,&#123;"ID":3,"Gender":"男","Name":"stu03"&#125;,&#123;"ID":4,"Gender":"男","Name":"stu04"&#125;,&#123;"ID":5,"Gender":"男","Name":"stu05"&#125;,&#123;"ID":6,"Gender":"男","Name":"stu06"&#125;,&#123;"ID":7,"Gender":"男","Name":"stu07"&#125;,&#123;"ID":8,"Gender":"男","Name":"stu08"&#125;,&#123;"ID":9,"Gender":"男","Name":"stu09"&#125;]&#125;`</span></span><br><span class="line">	c1 := &amp;Class&#123;&#125;</span><br><span class="line">	err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"json unmarshal failed!"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反</strong></p>
<p><strong>引号</strong>包裹起来，具体的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">"value1"</span> key2:<span class="string">"value2"</span>`</span><br></pre></td></tr></table></figure>

<p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个</p>
<p>键值对tag，不同的键值对之间使用空格分隔。</p>
<p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格</p>
<p>式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<p>例如我们为<code>Student</code>结构体的每个字段定义<code>json</code>序列化时使用的<code>Tag</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span>    <span class="string">`json:"id"`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">	Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">	name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">"男"</span>,</span><br><span class="line">		name:   <span class="string">"沙河娜扎"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"json marshal failed!"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"json str:%s\n"</span>, data) <span class="comment">//json str:&#123;"id":1,"Gender":"男"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h3><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来</p>
<p>看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int8</span></span><br><span class="line">	dreams []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.dreams = dreams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;name: <span class="string">"小王子"</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	data := []<span class="keyword">string</span>&#123;<span class="string">"吃饭"</span>, <span class="string">"睡觉"</span>, <span class="string">"打豆豆"</span>&#125;</span><br><span class="line">	p1.SetDreams(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 你真的想要修改 p1.dreams 吗？</span></span><br><span class="line">	data[<span class="number">1</span>] = <span class="string">"不睡觉"</span></span><br><span class="line">	fmt.Println(p1.dreams)  <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.dreams = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(dreams))</span><br><span class="line">	<span class="built_in">copy</span>(p.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/05/12/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1%E5%BA%94%E7%94%A8%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/12/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1%E5%BA%94%E7%94%A8%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">每日打卡应用文档</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-12T00:00:00+08:00">2019-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 14:09:37" itemprop="dateModified" datetime="2020-03-09T14:09:37+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">项目总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><p>每日早起打卡应用。</p>
<h4 id="数据表结构设计："><a href="#数据表结构设计：" class="headerlink" title="数据表结构设计："></a>数据表结构设计：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、表名：fa_clock_activity_list</span><br><span class="line">描述：活动记录表（每个活动为一个打卡周期）</span><br><span class="line">字段：</span><br><span class="line">`ID`	int		活动ID</span><br><span class="line">`HDMC`	varchar	活动名称</span><br><span class="line">`KSSJ`	int		活动开始时间</span><br><span class="line">`JSSJ`	int		活动结束时间</span><br><span class="line">`DKKSSJ`varchar	打卡开始时间</span><br><span class="line">`DKJSSJ`varchar	打卡结束时间</span><br><span class="line">`extro`	text	备用</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2、表名：fa_clock_apply_list</span><br><span class="line">表述：打卡活动报名表</span><br><span class="line">字段：</span><br><span class="line">`ID`	int		自增ID</span><br><span class="line">`XH`	varchar	学号</span><br><span class="line">`HDID`	int		活动ID 外键</span><br><span class="line">`BMSJ`	int		报名时间</span><br><span class="line">`LJTS`	int		活动内累计打卡天数</span><br><span class="line">`LXTS`	int		活动内连续打卡天数</span><br><span class="line">`maxLXTS`int	最大连续打卡天数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3、表名：fa_clock_user_list</span><br><span class="line">描述：打卡活动打卡记录表</span><br><span class="line">字段：</span><br><span class="line">`ID`	int		自增ID</span><br><span class="line">`XH`	varchar	学号</span><br><span class="line">`HDID`	int		活动ID</span><br><span class="line">`DKSJ`	int		打卡时间</span><br></pre></td></tr></table></figure>

<h4 id="接口设计："><a href="#接口设计：" class="headerlink" title="接口设计："></a>接口设计：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">1、miniapp/clock/index</span><br><span class="line">初始化接口</span><br><span class="line">@param int key[&quot;XH&quot;] &amp;&amp; $key[&quot;open_id&quot;]</span><br><span class="line">@return array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//活动未开始</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;success&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_status&quot;	=&gt;	[</span><br><span class="line">			&quot;is_activity&quot;	=&gt;	false, //当前没有活动</span><br><span class="line">			&quot;is_wait&quot;		=&gt;	true,//有活动但未开始，为false则表示无活动</span><br><span class="line">			&quot;start_time&quot;	=&gt;	&quot;&quot;,	//活动开始时间</span><br><span class="line">		],</span><br><span class="line">		&quot;personal_info&quot;		=&gt;	[],//个人信息</span><br><span class="line">		&quot;rank_info&quot;			=&gt;	[],//排行信息</span><br><span class="line">		&quot;rand_str&quot;			=&gt;	&quot;&quot;,//随机字符串</span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line">//活动已开始，且用户未报名</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;success&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_status&quot;	=&gt;	[</span><br><span class="line">			&quot;is_activity&quot;	=&gt;	true, //当前有活动</span><br><span class="line">			&quot;is_apply&quot;		=&gt;	false	//当前用户</span><br><span class="line">			&quot;activity_id&quot;	=&gt;	&quot;&quot;,//活动ID</span><br><span class="line">		],</span><br><span class="line">		&quot;personal_info&quot;		=&gt;	[],//个人信息</span><br><span class="line">		&quot;rank_info&quot;			=&gt;	[],//排行信息</span><br><span class="line">		&quot;rand_str&quot;			=&gt;	&quot;&quot;,//随机字符串</span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//活动已开始，且用户报名，尚未打卡</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;success&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_status&quot;	=&gt;	[</span><br><span class="line">			&quot;is_activity&quot;	=&gt;	true, //当前有活动</span><br><span class="line">			&quot;is_apply&quot;		=&gt;	true	//当前用户</span><br><span class="line">			&quot;is_dk&quot;			=&gt;	false,</span><br><span class="line">			&quot;dk_start_time&quot;	=&gt;	&quot;&quot;,//打卡开始时间</span><br><span class="line">			&quot;dk_end_time&quot;	=&gt;	&quot;&quot;,//打卡结束时间</span><br><span class="line">			&quot;activity_id&quot;	=&gt;	&quot;&quot;,//活动ID</span><br><span class="line">			&quot;can_dk&quot;		=&gt;	true,//是否可以打卡</span><br><span class="line">		],</span><br><span class="line">		&quot;personal_info&quot;		=&gt;	[],//个人信息</span><br><span class="line">		&quot;rank_info&quot;			=&gt;	[],//排行信息</span><br><span class="line">		&quot;rand_str&quot;			=&gt;	&quot;&quot;,//随机字符串</span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//活动已开始，且用户报名，已经打卡</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;success&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_status&quot;	=&gt;	[</span><br><span class="line">			&quot;is_activity&quot;	=&gt;	true, //当前有活动</span><br><span class="line">			&quot;is_apply&quot;		=&gt;	true	//当前用户</span><br><span class="line">			&quot;is_dk&quot;			=&gt;	true,</span><br><span class="line">			&quot;dk_next_time&quot;	=&gt;	&quot;&quot;,//距离下次打卡的时间</span><br><span class="line">		],</span><br><span class="line">		&quot;personal_info&quot;		=&gt;	[],//个人信息</span><br><span class="line">		&quot;rank_info&quot;			=&gt;	[],//排行信息</span><br><span class="line">		&quot;rand_str&quot;			=&gt;	&quot;&quot;,//随机字符串</span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//个人信息+排行信息</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;success&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;rand_str&quot;			=&gt;	&quot;&quot;,//随机字符串</span><br><span class="line">		&quot;clock_status&quot;	=&gt;	[],</span><br><span class="line">		&quot;personal_info&quot;	=&gt;	[</span><br><span class="line">			&quot;running_days&quot;			=&gt;	&quot;&quot;,//连续打卡天数</span><br><span class="line">			&quot;total_activity_days&quot;	=&gt;	&quot;&quot;,//活动期间内累计打卡天数</span><br><span class="line">			&quot;total_days&quot;			=&gt;	&quot;&quot;,//历史累计打卡天数</span><br><span class="line">		],</span><br><span class="line">		&quot;rank_info&quot;		=&gt;	[</span><br><span class="line">			&quot;runnging_list&quot;	=&gt;	[</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;clock_time&quot;=&gt;&quot;&quot;],</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;clock_time&quot;=&gt;&quot;&quot;],</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;clock_time&quot;=&gt;&quot;&quot;],</span><br><span class="line">				...</span><br><span class="line">			],</span><br><span class="line">			&quot;total_activity_list&quot;	=&gt;	[</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;nums&quot;=&gt;&quot;&quot;],</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;nums&quot;=&gt;&quot;&quot;],</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;nums&quot;=&gt;&quot;&quot;],</span><br><span class="line">				...</span><br><span class="line">			],</span><br><span class="line">			&quot;total_list&quot;			=&gt;	[</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;nums&quot;=&gt;&quot;&quot;],</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;nums&quot;=&gt;&quot;&quot;],</span><br><span class="line">				[&quot;XM&quot;=&gt;&quot;&quot;,&quot;YXMC&quot;=&gt;&quot;&quot;,&quot;nums&quot;=&gt;&quot;&quot;],</span><br><span class="line">				...</span><br><span class="line">			],</span><br><span class="line">	</span><br><span class="line">		],</span><br><span class="line">	]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2、miniapp/clock/apply</span><br><span class="line">报名接口</span><br><span class="line">@param int key[&quot;XH&quot;] &amp;&amp; $key[&quot;open_id&quot;] &amp;&amp; $key[&quot;activity_id&quot;]</span><br><span class="line">@return array</span><br><span class="line"></span><br><span class="line">//报名成功</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;报名成功&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_time&quot;	=&gt;	&quot;&quot;,//每天打卡时间</span><br><span class="line">	]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3、miniapp/clock/clock</span><br><span class="line">打卡接口</span><br><span class="line">@param int key[&quot;XH&quot;] &amp;&amp; $key[&quot;open_id&quot;] &amp;&amp; $key[&quot;activity_id&quot;]</span><br><span class="line">@return array</span><br><span class="line"></span><br><span class="line">//打卡成功</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;打卡成功&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_time&quot;	=&gt;	&quot;&quot;,//下次打卡时间</span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//打卡失败</span><br><span class="line">[</span><br><span class="line">	&quot;status&quot;	=&gt;	200,</span><br><span class="line">	&quot;msg&quot;		=&gt;	&quot;打卡失败，未到打卡时间&quot;,</span><br><span class="line">	&quot;data&quot;		=&gt;	[</span><br><span class="line">		&quot;clock_time&quot;	=&gt;	&quot;&quot;,//下次打卡时间</span><br><span class="line">	]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/05/06/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0--%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/06/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0--%E6%A0%88/" class="post-title-link" itemprop="url">Go基础数据结构实现--栈</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-06T00:00:00+08:00">2019-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 14:23:11" itemprop="dateModified" datetime="2020-03-09T14:23:11+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="顺序栈实现："><a href="#顺序栈实现：" class="headerlink" title="顺序栈实现："></a>顺序栈实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//go顺序栈实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SeqStack 顺序栈，使用数组构建</span></span><br><span class="line"><span class="keyword">type</span> SeqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	max  <span class="keyword">int</span></span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">	top  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 栈的初始化操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myStack *SeqStack)</span> <span class="title">New</span><span class="params">(size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	myStack.data = <span class="built_in">make</span>([]<span class="keyword">int</span>, size)</span><br><span class="line">	myStack.max = size</span><br><span class="line">	myStack.top = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 数据入栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myStack *SeqStack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> myStack.top == myStack.max<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	myStack.data[myStack.top] = value</span><br><span class="line">	myStack.top++</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 数据出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myStack *SeqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> myStack.top == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	value := myStack.data[myStack.top]</span><br><span class="line">	myStack.top--</span><br><span class="line">	<span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stack := SeqStack&#123;&#125;</span><br><span class="line">	stack.New(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表栈实现："><a href="#链表栈实现：" class="headerlink" title="链表栈实现："></a>链表栈实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go实现链表栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Node 链表结点定义</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="keyword">int</span></span><br><span class="line">	Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkStack 链表栈实现</span></span><br><span class="line"><span class="keyword">type</span> LinkStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	pop *Node <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//New 初始化链表栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(linkstack *LinkStack)</span> <span class="title">New</span><span class="params">()</span></span> &#123;</span><br><span class="line">	linkstack.pop = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 数据入栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(linkstack *LinkStack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	temp := <span class="built_in">new</span>(Node)</span><br><span class="line">	temp.Next = linkstack.pop</span><br><span class="line">	temp.Val = value</span><br><span class="line">	linkstack.pop = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Pop 数据出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(linkstack *LinkStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> linkstack.pop == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	data := linkstack.pop.Val</span><br><span class="line">	linkstack.pop = linkstack.pop.Next</span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ShowItem 打印栈中数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(linkstack *LinkStack)</span> <span class="title">ShowItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := linkstack.pop</span><br><span class="line">	dataArray := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		dataArray = <span class="built_in">append</span>(dataArray, p.Val)</span><br><span class="line">		p = p.Next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(dataArray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	linkstack := <span class="built_in">new</span>(LinkStack)</span><br><span class="line">	linkstack.New()</span><br><span class="line">	linkstack.Push(<span class="number">1</span>)</span><br><span class="line">	linkstack.Push(<span class="number">2</span>)</span><br><span class="line">	linkstack.Push(<span class="number">3</span>)</span><br><span class="line">	linkstack.Push(<span class="number">4</span>)</span><br><span class="line">	linkstack.ShowItem()</span><br><span class="line">	first := linkstack.Pop()</span><br><span class="line">	fmt.Println(first)</span><br><span class="line">	first = linkstack.Pop()</span><br><span class="line">	fmt.Println(first)</span><br><span class="line">	first = linkstack.Pop()</span><br><span class="line">	fmt.Println(first)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/05/05/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/05/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Go知识复习-基本数据类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-05T00:00:00+08:00">2019-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 15:33:50" itemprop="dateModified" datetime="2020-07-02T15:33:50+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go知识复习—基本数据类型"><a href="#Go知识复习—基本数据类型" class="headerlink" title="Go知识复习—基本数据类型"></a>Go知识复习—基本数据类型</h1><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型分为以下两个大类： 按长度分为：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 对应的无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>其中，<code>uint8</code>就是<code>byte</code>型。</p>
<p><img src="./Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/image-20200413145019727.png" alt="image-20200413145019727"></p>
<h4 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h4><p><img src="./Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/image-20200413150209313.png" alt="image-20200413150209313"></p>
<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>
<p><strong>注意事项：</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>
<h4 id="数字字面量语法"><a href="#数字字面量语法" class="headerlink" title="数字字面量语法"></a>数字字面量语法</h4><p><code>v := 0b00101101</code>， 代表二进制的 <code>101101</code>，相当于十进制的 <code>45</code>。<code>v := 0o377</code>，代表八进制的 <code>377</code>，相当于十进制的 <code>255</code>。 <code>v := 0x1p-2</code>，代表十六进制的<code>1</code>除以<code>2²</code>，也就是<code>0.25</code>。 而且还允许我们用 _ 来分隔数字，比如说：</p>
<p><code>v := 123_456</code> 等于 <code>123456</code>。</p>
<p>我们可以借助<code>fmt</code>函数来将一个整数以不同进制形式展示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 八进制  以0开头</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">	fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line"></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure>

<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为<code>32</code>位，<code>complex128</code>的实部和虚部为<code>64</code>位。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>Go</code>语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true</code>和<code>false</code>两个值。</p>
<p><strong>注意：</strong></p>
<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li><code>Go</code>语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>Go</code>语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（<code>int、bool、float32、float64</code> 等）一样。<code>Go</code>语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在<code>Go</code>语言的源码中直接添加非<code>ASCII</code>码字符.</p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p><img src="./Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/image-20200413151237829.png" alt="image-20200413151237829"></p>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p><code>Go</code>语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>

<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h4 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h4><p><img src="./Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/Go%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.assets/image-20200413151407501.png" alt="image-20200413151407501"></p>
<h4 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h4><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">'中'</span></span><br><span class="line">b := <span class="string">'x'</span></span><br></pre></td></tr></table></figure>

<p><code>Go</code>语言的字符有以下两种：</p>
<ol>
<li><code>uint8</code>类型，或者叫<code>byte</code> 型，代表了<code>ASCII码</code>的一个字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
<p><code>Go</code> 使用了特殊的 <code>rune</code> 类型来处理 <code>Unicode</code>，让基于 <code>Unicode</code> 的文本处理更为方便，也可以使用 <code>byte</code> 型进行默认字符串处理，性能和扩展性都有照顾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"hello世界"</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	sRune := []<span class="keyword">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sRune); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, sRune[i], sRune[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	traversalString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 228(ä) 184(¸) 150() 231(ç) 149() 140()</span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 19990(世) 30028(界)</span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 19990(世) 30028(界)</span><br></pre></td></tr></table></figure>

<p>因为<code>UTF8</code>编码下一个中文汉字由<code>3~4</code>个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个<code>byte</code>数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由<code>byte</code>字节组成，所以字符串的长度是<code>byte</code>字节的长度。 <code>rune</code>类型用来表示<code>utf8</code>字符，一个<code>rune</code>字符由一个或多个<code>byte</code>组成。</p>
<h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">"big"</span></span><br><span class="line">	<span class="comment">// 强制类型转换</span></span><br><span class="line">	byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">	byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">	s2 := <span class="string">"白萝卜"</span></span><br><span class="line">	runeS2 := []<span class="keyword">rune</span>(s2)</span><br><span class="line">	runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><code>Go</code>语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>
<p>比如计算直角三角形的斜边长时使用<code>math</code>包的<code>Sqrt()</code>函数，该函数接收的是<code>float64</code>类型的参数，而变量<code>a</code>和<code>b</code>都是<code>int</code>类型的，这个时候就需要将<code>a</code>和<code>b</code>强制类型转换为<code>float64</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">	c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写代码统计汉字数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unicode"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	s := <span class="string">"hello, 世界你好"</span></span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s&#123;</span><br><span class="line">		<span class="keyword">if</span> unicode.Is(unicode.Han, r) &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"汉字个数："</span>,count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/05/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PHPmyadmin%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E7%9A%84sql%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PHPmyadmin%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E7%9A%84sql%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">如何使用PHPmyadmin上传超过大小限制的sql文件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-03 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-03T00:00:00+08:00">2019-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 14:26:30" itemprop="dateModified" datetime="2020-03-09T14:26:30+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零碎知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="如何使用PHPmyadmin上传超过大小限制的sql文件"><a href="#如何使用PHPmyadmin上传超过大小限制的sql文件" class="headerlink" title="如何使用PHPmyadmin上传超过大小限制的sql文件"></a>如何使用PHPmyadmin上传超过大小限制的sql文件</h2><p>在PHPmyadmin中，上传SQL文件时通常会有50M等限制，想上传超过该大小限制的文件，尝试过修改php.ini但是效果不明显，后来发现一中十分简便的方法。</p>
<p>1、进入phpmyadmin文件夹 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/wwwroot/default/phpmyadmin</span><br><span class="line">vim config.sample.inc.php</span><br></pre></td></tr></table></figure>

<p>找到其中的两个配置，修改为upload与save</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cfg[&apos;UploadDir&apos;] = &apos;upload&apos;;</span><br><span class="line">$cfg[&apos;SaveDir&apos;] = &apos;save&apos;;</span><br></pre></td></tr></table></figure>

<p>之后在phpmyadmin目录下，新建一个文件夹upload，通过ftp服务将需要导入的数据库放入upload文件夹下</p>
<p>进入phpmyadmin的操作界面，选择从网站服务器上传文件夹 <strong>upload/</strong> 中选择 ，便可以进行上传。</p>
<p>-</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/04/18/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0--%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/18/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0--%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">Go基础数据结构实现--二叉树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-18 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-18T00:00:00+08:00">2019-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 14:20:15" itemprop="dateModified" datetime="2020-03-09T14:20:15+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h3 id="满二叉树的定义："><a href="#满二叉树的定义：" class="headerlink" title="满二叉树的定义："></a>满二叉树的定义：</h3><p>所有分支结点均存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。</p>
</li>
<li><h3 id="完全二叉树的定义："><a href="#完全二叉树的定义：" class="headerlink" title="完全二叉树的定义："></a>完全二叉树的定义：</h3></li>
<li><h3 id="二叉树的基本性质："><a href="#二叉树的基本性质：" class="headerlink" title="二叉树的基本性质："></a>二叉树的基本性质：</h3><ol>
<li><p>接下来的描述中有必要用到一些数学符号，因此我们再次规定一些符号 </p>
<p>ａ＾ｂ—— a的b的次方 （计算机常用，无需多言） </p>
<p>int_UP（）—— 向上取整（即去掉浮点数的小数部分，然后将整数部分加1） </p>
<p>int_DOWN（）—— 向下取整（即去掉浮点数的小数部分，只留整数部分） </p>
<p>log(a,b) —— 表示以a为底取b的对数</p>
</li>
<li><p>二叉树具有以下五个性质： </p>
<ol>
<li>在<strong>二叉树</strong>的第ｉ（ｉ&gt;=１）层最多有２＾(ｉ - １)个结点。 <ol start="2">
<li>深度为k(k&gt;=0)的<strong>二叉树</strong>最少有k个结点，最多有２＾ｋ－１个结点。 </li>
<li>对于任一棵<strong>非空二叉树</strong>，若其叶结点数为n0，度为2的非叶结点数为n2，则ｎ0 = ｎ2 ＋１。 </li>
<li>具有n个结点的<strong>完全二叉树</strong>的深度为int_UP（log(2，ｎ+1)）。 </li>
</ol>
</li>
<li>如果将一棵有n个结点的<strong>完全二叉树</strong>自顶向下，同一层自左向右连续给结点编号１，２，   ３，．．．．．．，ｎ，然后按此结点编号将树中各结点顺序的存放于一个一维数组，并简称编号为i的结点为结点i（ ｉ&gt;=１ &amp;&amp; ｉ&lt;=ｎ）,则有以下关系： <ol>
<li>若 ｉ= 1，则结点i为根，无父结点；若 ｉ&gt; 1，则结点 i 的父结点为结点int_DOWN（ｉ / ２）;</li>
<li>若 ２＊ｉ &lt;= ｎ，则结点 ｉ 的左子女为结点 ２＊ｉ； </li>
<li>若２＊ｉ＜＝ｎ，则结点ｉ的右子女为结点２＊ｉ＋１； </li>
<li>若结点编号ｉ为奇数，且ｉ！＝１，它处于右兄弟位置，则它的左兄弟为结点ｉ－１； </li>
<li>若结点编号ｉ为偶数，且ｉ！＝ｎ，它处于左兄弟位置，则它的右兄弟为结点ｉ＋１； <ol start="6">
<li>结点ｉ所在的层次为 int_DOWN（log（2，ｉ））＋１。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">  </span><br><span class="line">  import &quot;fmt&quot;</span><br><span class="line">  </span><br><span class="line">  //go实现二叉链表</span><br><span class="line">  </span><br><span class="line">  //BiNode 二叉树结点定义</span><br><span class="line">  type BiNode struct &#123;</span><br><span class="line">  	data   int</span><br><span class="line">  	lchild *BiNode</span><br><span class="line">  	rchild *BiNode</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //BiTree 二叉树定义</span><br><span class="line">  type BiTree struct &#123;</span><br><span class="line">  	root *BiNode</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //New 创建一棵空二叉树</span><br><span class="line">  func (bitree *BiTree) New() &#123;</span><br><span class="line">  </span><br><span class="line">  	bitree.root = bitree.Create(bitree.root)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //Create 创建一棵二叉树 此时括号中是否传参数并无影响。</span><br><span class="line">  func (bitree *BiTree) Create(bt *BiNode) *BiNode &#123;</span><br><span class="line">  	var number int</span><br><span class="line">  	fmt.Print(&quot;请输入存储的数字，负数表示空&quot;)</span><br><span class="line">  	fmt.Scanln(&amp;number)</span><br><span class="line">  	if number &lt; 0 &#123;</span><br><span class="line">  		bt = nil</span><br><span class="line">  	&#125; else &#123;</span><br><span class="line">  		bt = new(BiNode)</span><br><span class="line">  		bt.data = number</span><br><span class="line">  		bt.lchild = bitree.Create(bt.lchild)</span><br><span class="line">  		bt.rchild = bitree.Create(bt.rchild)</span><br><span class="line">  	&#125;</span><br><span class="line">  	return bt</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //PreOrder 前序遍历递归算法</span><br><span class="line">  func (bitree *BiTree) PreOrder(bt *BiNode) &#123;</span><br><span class="line">  	if bt == nil &#123;</span><br><span class="line">  		return</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Println(bt.data)       // 访问根节点bt的数据</span><br><span class="line">  	bitree.PreOrder(bt.lchild) // 前序递归遍历bt的左子树</span><br><span class="line">  	bitree.PreOrder(bt.rchild) // 前序递归遍历bt的右子树</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //InOrder 中序遍历递归算法</span><br><span class="line">  func (bitree *BiTree) InOrder(bt *BiNode) &#123;</span><br><span class="line">  	if bt == nil &#123; //递归调用的结束条件</span><br><span class="line">  		return</span><br><span class="line">  	&#125;</span><br><span class="line">  	bitree.InOrder(bt.lchild) // 中序递归遍历bt的左子树</span><br><span class="line">  	fmt.Println(bt.data)      // 访问根节点bt的数据</span><br><span class="line">  	bitree.InOrder(bt.rchild) //	中序递归遍历bt的右子树</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //PostOrder 后遍历递归算法</span><br><span class="line">  func (bitree *BiTree) PostOrder(bt *BiNode) &#123;</span><br><span class="line">  	if bt == nil &#123; //递归调用的结束条件</span><br><span class="line">  		return</span><br><span class="line">  	&#125;</span><br><span class="line">  	bitree.PostOrder(bt.lchild) // 后序递归遍历bt的左子树</span><br><span class="line">  	bitree.PostOrder(bt.rchild) // 后序递归遍历bt的右子树</span><br><span class="line">  	fmt.Println(bt.data)        // 访问根节点bt的数据</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // PreOrderNoRecursion 前序遍历非递归调用</span><br><span class="line">  func (bitree *BiTree) PreOrderNoRecursion() &#123;</span><br><span class="line">  	fmt.Println(&quot;前序遍历非递归调用打印：&quot;)</span><br><span class="line">  	if bitree.root != nil &#123;</span><br><span class="line">  		linkStack := []*BiNode&#123;&#125;</span><br><span class="line">  		linkStack = append(linkStack, bitree.root)</span><br><span class="line">  		for len(linkStack) &gt; 0 &#123;</span><br><span class="line">  			link := linkStack[len(linkStack)-1]</span><br><span class="line">  			linkStack = linkStack[:len(linkStack)-1]</span><br><span class="line">  			fmt.Println(link.data)</span><br><span class="line">  			if link.rchild != nil &#123;</span><br><span class="line">  				linkStack = append(linkStack, link.rchild)</span><br><span class="line">  			&#125;</span><br><span class="line">  			if link.lchild != nil &#123;</span><br><span class="line">  				linkStack = append(linkStack, link.lchild)</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //PreOrderNoRecursion 前序遍历非递归调用</span><br><span class="line">  // func (bitree *BiTree) PreOrderNoRecursion() &#123;</span><br><span class="line">  // 	top := -1 //栈顶指针</span><br><span class="line">  // 	// tempStack := []*BiNode&#123;&#125;</span><br><span class="line">  // 	tempStack := make([]*BiNode, 20)</span><br><span class="line">  // 	link := bitree.root</span><br><span class="line">  // 	for top != -1 || link != nil &#123;</span><br><span class="line">  // 		for link != nil &#123;</span><br><span class="line">  // 			fmt.Println(link.data)</span><br><span class="line">  // 			// tempStack = append(tempStack, link)</span><br><span class="line">  // 			top++</span><br><span class="line">  // 			tempStack[top] = link</span><br><span class="line">  // 			link = link.lchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 		if top != -1 &#123;</span><br><span class="line">  // 			link = tempStack[top]</span><br><span class="line">  // 			top--</span><br><span class="line">  // 			link = link.rchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 	&#125;</span><br><span class="line">  // &#125;</span><br><span class="line">  // PreOrderNoRecursion 前序遍历非递归调用</span><br><span class="line">  // func (bitree *BiTree) PreOrderNoRecursion() &#123;</span><br><span class="line">  // 	tempStack := []*BiNode&#123;&#125;</span><br><span class="line">  // 	link := bitree.root</span><br><span class="line">  // 	for len(tempStack) != 0 || link != nil &#123;</span><br><span class="line">  // 		for link != nil &#123;</span><br><span class="line">  // 			fmt.Println(link.data)</span><br><span class="line">  // 			tempStack = append(tempStack, link)</span><br><span class="line">  // 			link = link.lchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 		if len(tempStack) != 0 &#123;</span><br><span class="line">  // 			link = tempStack[len(tempStack)-1]</span><br><span class="line">  // 			tempStack = tempStack[:len(tempStack)-1]</span><br><span class="line">  // 			link = link.rchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 	&#125;</span><br><span class="line">  // &#125;</span><br><span class="line">  //PreOrderNoRecursion 前序遍历非递归调用</span><br><span class="line">  // func (bitree *BiTree) PreOrderNoRecursion() &#123;</span><br><span class="line">  // 	tempStack := []*BiNode&#123;&#125;</span><br><span class="line">  // 	link := bitree.root</span><br><span class="line">  // 	top := -1</span><br><span class="line">  // 	for top != -1 || link != nil &#123;</span><br><span class="line">  // 		for link != nil &#123;</span><br><span class="line">  // 			fmt.Println(link.data)</span><br><span class="line">  // 			tempStack = append(tempStack, link)</span><br><span class="line">  // 			top = top + 1</span><br><span class="line">  // 			link = link.lchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 		if top != -1 &#123;</span><br><span class="line">  // 			link = tempStack[top]</span><br><span class="line">  // 			tempStack = tempStack[:len(tempStack)-1]</span><br><span class="line">  // 			top = top - 1</span><br><span class="line">  // 			link = link.rchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 	&#125;</span><br><span class="line">  // &#125;</span><br><span class="line">  </span><br><span class="line">  //InOrderNoRecursion 非递归中序遍历</span><br><span class="line">  // func (bitree *BiTree) InOrderNoRecursion() &#123;</span><br><span class="line">  // 	tempStack := []*BiNode&#123;&#125;</span><br><span class="line">  // 	link := bitree.root</span><br><span class="line">  // 	top := -1</span><br><span class="line">  // 	for top != -1 || link != nil &#123;</span><br><span class="line">  // 		for link != nil &#123;</span><br><span class="line">  // 			tempStack = append(tempStack, link)</span><br><span class="line">  // 			top = top + 1</span><br><span class="line">  // 			link = link.lchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 		if top != -1 &#123;</span><br><span class="line">  // 			link = tempStack[top]</span><br><span class="line">  // 			fmt.Println(link.data)</span><br><span class="line">  // 			tempStack = tempStack[:len(tempStack)-1]</span><br><span class="line">  // 			top = top - 1</span><br><span class="line">  // 			link = link.rchild</span><br><span class="line">  // 		&#125;</span><br><span class="line">  // 	&#125;</span><br><span class="line">  // &#125;</span><br><span class="line">  // InOrderNoRecursion 非递归中序遍历</span><br><span class="line">  func (bitree *BiTree) InOrderNoRecursion() &#123;</span><br><span class="line">  	tempStack := []*BiNode&#123;&#125;</span><br><span class="line">  	link := bitree.root</span><br><span class="line">  	for len(tempStack) &gt; 0 || link != nil &#123;</span><br><span class="line">  		if link != nil &#123;</span><br><span class="line">  			tempStack = append(tempStack, link)</span><br><span class="line">  			link = link.lchild</span><br><span class="line">  		&#125; else &#123;</span><br><span class="line">  			link = tempStack[len(tempStack)-1]</span><br><span class="line">  			fmt.Println(link.data)</span><br><span class="line">  			tempStack = tempStack[:len(tempStack)-1]</span><br><span class="line">  			link = link.rchild</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // PosOrderNoRecursion 非递归后序遍历</span><br><span class="line">  func (bitree *BiTree) PosOrderNoRecursion() &#123;</span><br><span class="line">  	if bitree.root != nil &#123;</span><br><span class="line">  		linkStack := []*BiNode&#123;&#125;</span><br><span class="line">  		helpStack := []*BiNode&#123;&#125;</span><br><span class="line">  		linkStack = append(linkStack, bitree.root)</span><br><span class="line">  		for len(linkStack) &gt; 0 &#123;</span><br><span class="line">  			link := linkStack[len(linkStack)-1]</span><br><span class="line">  			helpStack = append(helpStack, link)</span><br><span class="line">  			linkStack = linkStack[:len(linkStack)-1]</span><br><span class="line">  			if link.lchild != nil &#123;</span><br><span class="line">  				linkStack = append(linkStack, link.lchild)</span><br><span class="line">  			&#125;</span><br><span class="line">  			if link.rchild != nil &#123;</span><br><span class="line">  				linkStack = append(linkStack, link.rchild)</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		for len(helpStack) &gt; 0 &#123;</span><br><span class="line">  			fmt.Println(helpStack[len(helpStack)-1].data)</span><br><span class="line">  			helpStack = helpStack[:len(helpStack)-1]</span><br><span class="line">  		&#125;</span><br><span class="line">  </span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	myTree := new(BiTree)</span><br><span class="line">  	myTree.New() </span><br><span class="line">  	// myTree.PreOrder(myTree.root)</span><br><span class="line">  	myTree.PosOrderNoRecursion()</span><br><span class="line">  	// myTree.PostOrder(myTree.root)</span><br><span class="line">  	// myTree.InOrder(myTree.root)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chdliutao.top/2019/04/03/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0--%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘涛">
      <meta itemprop="description" content="好好写代码，开发优质产品。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHD-刘涛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0--%E5%9B%BE/" class="post-title-link" itemprop="url">Go基础数据结构实现--图</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-03 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-03T00:00:00+08:00">2019-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 14:21:00" itemprop="dateModified" datetime="2020-03-09T14:21:00+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="注意图的各种定义。"><a href="#注意图的各种定义。" class="headerlink" title="注意图的各种定义。"></a>注意图的各种定义。</h3><p>图分为无向图和有向图。无向图由顶点和边组成。有向图由顶点和弧组成。分为弧头和弧尾。</p>
<p>简单图。完全图。度。入度，出度。网。连通图。强连通图。连通分量。强连通分量。</p>
<p>存储结构：邻接表，邻接矩阵。</p>
<p>邻接矩阵（无向图）：用一个一维数组表示顶点，二维数组表示边。两顶点有边则为1，反之为0。是对称矩阵。<br>邻接矩阵（有向图）：用一个一维数组表示顶点，二维数组表示边。弧头为x，弧尾为y，对应1。非对称矩阵。</p>
<p>邻接矩阵（网）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">//代码实现</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//MGraph 图结构体</span><br><span class="line">type MGraph struct &#123;</span><br><span class="line">	vertex             []int   //用来存放图中顶点的数组</span><br><span class="line">	arc                [][]int //用来存放图中边的数组</span><br><span class="line">	vertextNum, arcNum int     //顶点以及边的个数</span><br><span class="line">	visited            []int   //用来存放深度遍历时已经遍历过的顶点</span><br><span class="line">	Q                  []int   //队列，用于广度优先遍历</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//New 构造函数</span><br><span class="line">/*</span><br><span class="line">构造函数伪代码:</span><br><span class="line">1.确定图的顶点个数和边的个数;</span><br><span class="line">2.输入顶点信息存储在一维数组vertex中;</span><br><span class="line">3.初始化邻接矩阵;</span><br><span class="line">4.依次输入每条边存储在邻接矩阵arc中:</span><br><span class="line">	4.1	输入边依附的两个顶点的编号i,j;</span><br><span class="line">	4.2	将邻接矩阵的第i行第j列的元素值置为1;</span><br><span class="line">	4.3	将邻接矩阵的第j行第i列的元素值置为1;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">func (mgraph *MGraph) New(data []int, n int, e int) &#123;</span><br><span class="line">	mgraph.vertextNum = n</span><br><span class="line">	mgraph.arcNum = e</span><br><span class="line">	mgraph.vertex = make([]int, n)  // n 是顶点数量</span><br><span class="line">	mgraph.visited = make([]int, n) // n 是顶点数量，记录被遍历过的顶点</span><br><span class="line"></span><br><span class="line">	mgraph.arc = make([][]int, n) //	e 是边的数量</span><br><span class="line">	for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">		mgraph.arc[i] = make([]int, n)</span><br><span class="line">	&#125;</span><br><span class="line">	//data是顶点的数组</span><br><span class="line">	for i := 0; i &lt; mgraph.vertextNum; i++ &#123;</span><br><span class="line">		mgraph.vertex[i] = data[i]</span><br><span class="line">	&#125;</span><br><span class="line">	//初始化邻接矩阵</span><br><span class="line">	for i := 0; i &lt; mgraph.vertextNum; i++ &#123;</span><br><span class="line">		for j := 0; j &lt; mgraph.vertextNum; j++ &#123;</span><br><span class="line">			mgraph.arc[i][j] = 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//输入边的关系</span><br><span class="line">	var num1 int</span><br><span class="line">	var num2 int</span><br><span class="line">	for i := 0; i &lt; mgraph.arcNum; i++ &#123;</span><br><span class="line">		fmt.Print(&quot;请输入边的第一个顶点&quot;)</span><br><span class="line">		fmt.Scanln(&amp;num1)</span><br><span class="line">		fmt.Print(&quot;请输入边的第二个顶点&quot;)</span><br><span class="line">		fmt.Scanln(&amp;num2)</span><br><span class="line">		mgraph.arc[num1][num2] = 1</span><br><span class="line">		mgraph.arc[num2][num1] = 1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//deleteVisited 清除visited中的遍历数据</span><br><span class="line">func (mgraph *MGraph) deleteVisited() &#123;</span><br><span class="line">	for i := 0; i &lt; len(mgraph.visited); i++ &#123;</span><br><span class="line">		mgraph.visited[i] = 0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DFSTraverse 图的深度优先遍历</span><br><span class="line">func (mgraph *MGraph) DFSTraverse(v int) &#123;</span><br><span class="line">	fmt.Println(mgraph.vertex[v])</span><br><span class="line">	mgraph.visited[v] = 1</span><br><span class="line">	for j := 0; j &lt; mgraph.vertextNum; j++ &#123;</span><br><span class="line">		if mgraph.arc[v][j] == 1 &amp;&amp; mgraph.visited[j] == 0 &#123;</span><br><span class="line">			mgraph.DFSTraverse(j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BFSTraverse 图的广度优先遍历</span><br><span class="line">func (mgraph *MGraph) BFSTraverse(v int) &#123;</span><br><span class="line">	fmt.Println(mgraph.vertex[v])</span><br><span class="line">	mgraph.visited[v] = 1</span><br><span class="line">	mgraph.Q = append(mgraph.Q, v) //被访问节点入队列</span><br><span class="line">	for len(mgraph.Q) &gt; 0 &#123;</span><br><span class="line">		v = mgraph.Q[0]</span><br><span class="line">		mgraph.Q = mgraph.Q[1:] //模拟出队列操作</span><br><span class="line">		for j := 0; j &lt; mgraph.vertextNum; j++ &#123;</span><br><span class="line">			if mgraph.arc[v][j] == 1 &amp;&amp; mgraph.visited[j] == 0 &#123;</span><br><span class="line">				fmt.Println(mgraph.vertex[j])</span><br><span class="line">				mgraph.visited[j] = 1</span><br><span class="line">				mgraph.Q = append(mgraph.Q, j)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;图的广度优先遍历结束&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	mgraph := new(MGraph)</span><br><span class="line">	mgraph.New([]int&#123;0, 1, 2, 3&#125;, 4, 5)</span><br><span class="line">	mgraph.BFSTraverse(1)</span><br><span class="line">	mgraph.deleteVisited()</span><br><span class="line">	mgraph.DFSTraverse(1)</span><br><span class="line">	mgraph.deleteVisited()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>邻接表（无向图）：顶点用一维数组表示，</p>
<p>邻接表（有向图）：只能表示出度或者入度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//采用邻接表来存储图</span><br><span class="line"></span><br><span class="line">//ArcNode 边表节点</span><br><span class="line">type ArcNode struct &#123;</span><br><span class="line">	adjvex int</span><br><span class="line">	next   *ArcNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//VerTexNode 定义顶点表节点</span><br><span class="line">type VerTexNode struct &#123;</span><br><span class="line">	vertex    int</span><br><span class="line">	firstedge *ArcNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ALGraph 结构体定义</span><br><span class="line">type ALGraph struct &#123;</span><br><span class="line">	adjlist    []VerTexNode //存放顶点表的数组</span><br><span class="line">	vertextNum int          //图的顶点的数量</span><br><span class="line">	arcNum     int          //图的边的数量</span><br><span class="line">	visited    []int        //遍历时记录顶点是否被遍历过</span><br><span class="line">	Q          []int        //队列，用于广度优先遍历</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Create 无向图邻接表构造函数！！</span><br><span class="line">func (algraph *ALGraph) Create(data []int, n int, e int) &#123;</span><br><span class="line">	algraph.adjlist = make([]VerTexNode, n)</span><br><span class="line">	algraph.visited = make([]int, n)</span><br><span class="line">	algraph.arcNum = e</span><br><span class="line">	algraph.vertextNum = n</span><br><span class="line">	for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">		algraph.adjlist[i].vertex = i</span><br><span class="line">		algraph.adjlist[i].firstedge = nil</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; e; i++ &#123;</span><br><span class="line">		num1, num2 := 0, 0</span><br><span class="line">		fmt.Println(&quot;请输入第&quot; + strconv.Itoa(i) + &quot;条边的起点&quot;)</span><br><span class="line">		fmt.Scanln(&amp;num1)</span><br><span class="line">		fmt.Println(&quot;请输入第&quot; + strconv.Itoa(i) + &quot;条边的终点&quot;)</span><br><span class="line">		fmt.Scanln(&amp;num2)</span><br><span class="line">		temp := new(ArcNode)</span><br><span class="line">		temp.adjvex = num2</span><br><span class="line">		temp.next = algraph.adjlist[num1].firstedge</span><br><span class="line">		algraph.adjlist[num1].firstedge = temp</span><br><span class="line"></span><br><span class="line">		temp1 := new(ArcNode)</span><br><span class="line">		temp1.adjvex = num1</span><br><span class="line">		temp1.next = algraph.adjlist[num2].firstedge</span><br><span class="line">		algraph.adjlist[num2].firstedge = temp1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//New 有向图邻接表构造函数！！！！！</span><br><span class="line">func (algraph *ALGraph) New(data []int, n int, e int) &#123;</span><br><span class="line">	algraph.adjlist = make([]VerTexNode, n)</span><br><span class="line">	algraph.visited = make([]int, n)</span><br><span class="line">	algraph.arcNum = e</span><br><span class="line">	algraph.vertextNum = n</span><br><span class="line">	for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">		algraph.adjlist[i].vertex = i</span><br><span class="line">		algraph.adjlist[i].firstedge = nil</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; e; i++ &#123;</span><br><span class="line">		num1, num2 := 0, 0</span><br><span class="line">		fmt.Println(&quot;请输入第&quot; + strconv.Itoa(i) + &quot;条边的起点&quot;)</span><br><span class="line">		fmt.Scanln(&amp;num1)</span><br><span class="line">		fmt.Println(&quot;请输入第&quot; + strconv.Itoa(i) + &quot;条边的终点&quot;)</span><br><span class="line">		fmt.Scanln(&amp;num2)</span><br><span class="line">		temp := new(ArcNode)</span><br><span class="line">		temp.adjvex = num2</span><br><span class="line">		temp.next = algraph.adjlist[num1].firstedge</span><br><span class="line">		algraph.adjlist[num1].firstedge = temp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//deleteVisited 清空visited数组</span><br><span class="line">func (algraph *ALGraph) deleteVisited() &#123;</span><br><span class="line">	for i := 0; i &lt; len(algraph.visited); i++ &#123;</span><br><span class="line">		algraph.visited[i] = 0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DFSTraverse 深度优先遍历</span><br><span class="line">func (algraph *ALGraph) DFSTraverse(v int) &#123;</span><br><span class="line">	fmt.Println(algraph.adjlist[v].vertex)</span><br><span class="line">	algraph.visited[v] = 1</span><br><span class="line">	p := algraph.adjlist[v].firstedge</span><br><span class="line">	for p != nil &#123;</span><br><span class="line">		j := p.adjvex</span><br><span class="line">		if algraph.visited[j] == 0 &#123;</span><br><span class="line">			algraph.DFSTraverse(j)</span><br><span class="line">		&#125;</span><br><span class="line">		p = p.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BFSTraverse 广度优先遍历</span><br><span class="line">func (algraph *ALGraph) BFSTraverse(v int) &#123;</span><br><span class="line">	fmt.Println(algraph.adjlist[v].vertex)</span><br><span class="line">	algraph.visited[v] = 1</span><br><span class="line">	algraph.Q = append(algraph.Q, v) //访问过的顶点入队列</span><br><span class="line">	for len(algraph.Q) &gt; 0 &#123;</span><br><span class="line">		v = algraph.Q[0]</span><br><span class="line">		algraph.Q = algraph.Q[1:]</span><br><span class="line"></span><br><span class="line">		p := algraph.adjlist[v].firstedge</span><br><span class="line">		for p != nil &#123;</span><br><span class="line">			j := p.adjvex</span><br><span class="line">			if algraph.visited[j] == 0 &#123;</span><br><span class="line">				fmt.Println(algraph.adjlist[j].vertex)</span><br><span class="line">				algraph.visited[j] = 1</span><br><span class="line">				algraph.Q = append(algraph.Q, j)</span><br><span class="line">			&#125;</span><br><span class="line">			p = p.next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;广度优先遍历结束&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	mygraph := new(ALGraph)</span><br><span class="line">	mygraph.Create([]int&#123;0, 1, 2, 3, 4&#125;, 5, 7)</span><br><span class="line">	mygraph.BFSTraverse(1)</span><br><span class="line">	mygraph.deleteVisited()</span><br><span class="line">	mygraph.DFSTraverse(1)</span><br><span class="line">	mygraph.deleteVisited()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘涛</p>
  <div class="site-description" itemprop="description">好好写代码，开发优质产品。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备19032471号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">2019-2020 chdliutao.top 版权所有</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
